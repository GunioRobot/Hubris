-- GENERATED by C->Haskell Compiler, version 0.16.0 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "lib/RubyMap.chs" #-}{-# LANGUAGE ForeignFunctionInterface #-}
-- {-# LANGUAGE TypeSynonymInstances #-}

module RubyMap where

-- import Control.Applicative
-- import Control.Monad
import Data.Word
-- import Foreign.Ptr
import Foreign.C.Types	
import Foreign.C.String
-- import Foreign.Storable
import System.IO.Unsafe (unsafePerformIO)

-- import Foreign.Marshal.Array


{-# LINE 19 "lib/RubyMap.chs" #-}

data RubyType = RT_NONE
              | RT_NIL
              | RT_OBJECT
              | RT_CLASS
              | RT_ICLASS
              | RT_MODULE
              | RT_FLOAT
              | RT_STRING
              | RT_REGEXP
              | RT_ARRAY
              | RT_FIXNUM
              | RT_HASH
              | RT_STRUCT
              | RT_BIGNUM
              | RT_FILE
              | RT_TRUE
              | RT_FALSE
              | RT_DATA
              | RT_MATCH
              | RT_SYMBOL
              | RT_UNDEF
              | RT_NODE
              | RT_MASK
              deriving (Eq,Show)
instance Enum RubyType where
  fromEnum RT_NONE = 0
  fromEnum RT_NIL = 1
  fromEnum RT_OBJECT = 2
  fromEnum RT_CLASS = 3
  fromEnum RT_ICLASS = 4
  fromEnum RT_MODULE = 5
  fromEnum RT_FLOAT = 6
  fromEnum RT_STRING = 7
  fromEnum RT_REGEXP = 8
  fromEnum RT_ARRAY = 9
  fromEnum RT_FIXNUM = 10
  fromEnum RT_HASH = 11
  fromEnum RT_STRUCT = 12
  fromEnum RT_BIGNUM = 13
  fromEnum RT_FILE = 14
  fromEnum RT_TRUE = 32
  fromEnum RT_FALSE = 33
  fromEnum RT_DATA = 34
  fromEnum RT_MATCH = 35
  fromEnum RT_SYMBOL = 36
  fromEnum RT_UNDEF = 60
  fromEnum RT_NODE = 63
  fromEnum RT_MASK = 63

  toEnum 0 = RT_NONE
  toEnum 1 = RT_NIL
  toEnum 2 = RT_OBJECT
  toEnum 3 = RT_CLASS
  toEnum 4 = RT_ICLASS
  toEnum 5 = RT_MODULE
  toEnum 6 = RT_FLOAT
  toEnum 7 = RT_STRING
  toEnum 8 = RT_REGEXP
  toEnum 9 = RT_ARRAY
  toEnum 10 = RT_FIXNUM
  toEnum 11 = RT_HASH
  toEnum 12 = RT_STRUCT
  toEnum 13 = RT_BIGNUM
  toEnum 14 = RT_FILE
  toEnum 32 = RT_TRUE
  toEnum 33 = RT_FALSE
  toEnum 34 = RT_DATA
  toEnum 35 = RT_MATCH
  toEnum 36 = RT_SYMBOL
  toEnum 60 = RT_UNDEF
  toEnum 63 = RT_NODE
  toEnum 63 = RT_MASK
  toEnum unmatched = error ("RubyType.toEnum: Cannot match " ++ show unmatched)
 -- maybe Ord?
data RubyConsts = RUBY_Qfalse 
                | RUBY_Qtrue  
                | RUBY_Qnil   
                | RUBY_Qundef 

instance Enum RubyConsts where
  fromEnum RUBY_Qfalse = 0
  fromEnum RUBY_Qtrue = 2
  fromEnum RUBY_Qnil = 4
  fromEnum RUBY_Qundef = 6

  toEnum 0 = RUBY_Qfalse
  toEnum 2 = RUBY_Qtrue
  toEnum 4 = RUBY_Qnil
  toEnum 6 = RUBY_Qundef
type Value = CULong -- FIXME, we'd prefer to import the type VALUE directly
foreign import ccall unsafe "ruby.h rb_str2cstr"    rb_str2cstr    :: Value -> CInt -> CString
foreign import ccall unsafe "ruby.h rb_str_new2"    rb_str_new2    :: CString -> Value
foreign import ccall unsafe "ruby.h rb_ary_new2"    rb_ary_new2    :: CLong -> IO Value
foreign import ccall unsafe "ruby.h rb_ary_push"    rb_ary_push    :: Value -> Value -> IO ()
foreign import ccall unsafe "ruby.h rb_float_new"   rb_float_new   :: Double -> Value
foreign import ccall unsafe "ruby.h rb_big2str"     rb_big2str     :: Value -> Int -> Value
foreign import ccall unsafe "ruby.h rb_str_to_inum" rb_str_to_inum :: Value -> Int -> Int -> Value

-- we're being a bit filthy here - the interface is all macros, so we're digging in to find what it actually is
foreign import ccall unsafe "rshim.h rb_ary_len" rb_ary_len :: Value -> CUInt
foreign import ccall unsafe "rshim.h rtype"      rtype      :: Value -> Int
foreign import ccall unsafe "rshim.h int2fix"    int2fix    :: Int -> Value
foreign import ccall unsafe "rshim.h fix2int"    fix2int    :: Value -> Int
foreign import ccall unsafe "rshim.h num2dbl"    num2dbl    :: Value -> Double  -- technically CDoubles, but jhc promises they're the same

-- this line crashes jhc
foreign import ccall unsafe "intern.h rb_ary_entry" rb_ary_entry :: Value -> CLong -> IO Value

foreign import ccall safe "ruby.h rb_raise" rb_raise :: Value -> CString -> IO ()
foreign import ccall unsafe "ruby.h rb_eval_string" rb_eval_string :: CString -> Value




data RValue = T_NIL  
            | T_FLOAT Double
            | T_STRING String

            -- List is non-ideal. Switch to uvector? Array? There's always going
            -- to be an extraction step to pull the RValues out.
            | T_ARRAY [RValue]
            | T_FIXNUM Int 
            | T_HASH  Int -- definitely FIXME - native ruby hashes, or going to transliterate into Data.Map?
            | T_BIGNUM Integer    

            -- technically, these are mapping over the types True and False,
            -- I'm going to treat them as values, though.
            | T_TRUE  
            | T_FALSE      

            | T_SYMBOL Word -- interned string

-- These are the other basic Ruby structures that we're not handling yet.
--          | T_REGEXP     
--          | T_FILE
--          | T_STRUCT     
--          | T_DATA       
--          | T_OBJECT 
--          | T_CLASS      
--          | T_MODULE     

toRuby :: RValue -> Value
toRuby r = case r of
           T_FLOAT d -> rb_float_new d
           -- need to take the address of the cstr, just cast it to a value
           -- sadly no bytestrings yet - unpack it to a list. yeah it's ugly.
           T_STRING str -> rb_str_new2 $ unsafePerformIO $ newCAString str
           T_FIXNUM i -> int2fix i

           -- so this is just bizarre - there's no boolean type. True and False have their own types
           -- as well as their own values.
           T_TRUE     -> fromIntegral $ fromEnum RUBY_Qtrue
           T_FALSE    -> fromIntegral $ fromEnum RUBY_Qfalse
           T_NIL      -> fromIntegral $ fromEnum RUBY_Qnil
           T_ARRAY l  -> unsafePerformIO $ do
                           ary <- rb_ary_new2 $ fromIntegral $ length l
                           mapM_ (rb_ary_push ary . toRuby) l
                           return ary
           T_BIGNUM b -> rb_str_to_inum (rb_str_new2 $ unsafePerformIO $ newCAString $ show b) 10 1
           _          -> error "sorry, haven't implemented that yet."

fromRuby :: Value -> RValue
fromRuby v = case target of
               RT_NIL -> T_NIL
               RT_FIXNUM -> T_FIXNUM $ fix2int v
               RT_STRING -> T_STRING $ unsafePerformIO $ peekCString $ rb_str2cstr v 0
               RT_FLOAT ->  T_FLOAT $ num2dbl v
               RT_BIGNUM -> T_BIGNUM $ read  $ unsafePerformIO $ peekCString $ rb_str2cstr (rb_big2str v 10) 0
               RT_TRUE -> T_TRUE
               RT_FALSE -> T_FALSE
               RT_ARRAY -> T_ARRAY $ map fromRuby $ unsafePerformIO  $ mapM (rb_ary_entry v . fromIntegral) [0..(rb_ary_len v) - 1]

               _ -> error (show target)
      where target :: RubyType
            target = toEnum $ rtype v

-- utility stuff

throwException :: String -> IO Value
throwException s = do he <- newCAString "HaskellError"
                      err <- newCAString s
                      rb_raise (rb_eval_string he) err
                      error "shouldn't ever get here"

